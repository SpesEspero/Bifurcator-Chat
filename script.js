let messages = [
    {
        id: '1'
        , text: 'Lorem Ipsum - это текст-"рыба", часто используемый в печати и вэб-дизайне. Lorem Ipsum является стандартной "рыбой" для текстов на латинице с начала XVI века. В то время некий безымянный печатник создал большую коллекцию размеров и форм шрифтов, используя Lorem Ipsum для распечатки образцов. Lorem Ipsum не только успешно пережил без заметных изменений пять веков, но и перешагнул в электронный дизайн. Его популяризации в новое время послужили публикация листов Letraset с образцами Lorem Ipsum в 60-х годах и, в более недавнее время, программы электронной вёрстки типа Aldus PageMaker, в шаблонах которых используется Lorem Ipsum'
        , createdAt: new Date('2021-05-05T12:18:01')
        , author: 'Ян'
        , isPersonal: false
  },
     {
        id: '2'
        , text: 'Давно выяснено, что при оценке дизайна и композиции читаемый текст мешает сосредоточиться. Lorem Ipsum используют потому, что тот обеспечивает более или менее стандартное заполнение шаблона, а также реальное распределение букв и пробелов в абзацах, которое не получается при простой дубликации "Здесь ваш текст.. Здесь ваш текст.. Здесь ваш текст.." Многие программы электронной вёрстки и редакторы HTML используют Lorem Ipsum в качестве текста по умолчанию, так что поиск по ключевым словам "lorem ipsum" сразу показывает, как много веб-страниц всё ещё дожидаются своего настоящего рождения. За прошедшие годы текст Lorem Ipsum получил много версий. Некоторые версии появились по ошибке, некоторые - намеренно (например, юмористические варианты).'
        , createdAt: new Date('2021-05-05T12:18:20')
        , author: 'Ник'
        , isPersonal: false
  },
     {
        id: '3'
        , text: 'Многие думают, что Lorem Ipsum - взятый с потолка псевдо-латинский набор слов, но это не совсем так. Его корни уходят в один фрагмент классической латыни 45 года н.э., то есть более двух тысячелетий назад. Ричард МакКлинток, профессор латыни из колледжа Hampden-Sydney, штат Вирджиния, взял одно из самых странных слов в Lorem Ipsum, "consectetur", и занялся его поисками в классической латинской литературе.'
        , createdAt: new Date('2021-05-05T12:19:19')
        , author: 'Майк'
        , isPersonal: false
  }
    , {
        id: '4'
        , text: 'В результате он нашёл неоспоримый первоисточник Lorem Ipsum в разделах 1.10.32 и 1.10.33 книги "de Finibus Bonorum et Malorum" ("О пределах добра и зла"), написанной Цицероном в 45 году н.э. Этот трактат по теории этики был очень популярен в эпоху Возрождения. Первая строка Lorem Ipsum, "Lorem ipsum dolor sit amet..", происходит от одной из строк в разделе 1.10.32'
        , createdAt: new Date('2021-05-05T12:20:20')
        , author: 'Ник'
        , isPersonal: false
  }
    , {
        id: '5'
        , text: 'Классический текст Lorem Ipsum, используемый с XVI века, приведён ниже. Также даны разделы 1.10.32 и 1.10.33 "de Finibus Bonorum et Malorum" Цицерона и их английский перевод, сделанный H. Rackham, 1914 год.'
        , createdAt: new Date('2021-05-05T12:21:21')
        , author: 'Майк'
        , isPersonal: false
  }
    , {
        id: '6'
        , text: 'Есть много вариантов Lorem Ipsum, но большинство из них имеет не всегда приемлемые модификации, например, юмористические вставки или слова, которые даже отдалённо не напоминают латынь.'
        , createdAt: new Date('2021-05-05T12:22:05')
        , author: 'Ник'
        , isPersonal: true
        , to: 'Майк'
  }
    , {
        id: '7'
        , text: 'Ричард МакКлинток, профессор латыни из колледжа Hampden-Sydney, штат Вирджиния, взял одно из самых странных слов в Lorem Ipsum, "consectetur", и занялся его поисками в классической латинской литературе.'
        , createdAt: new Date('2021-05-05T12:22:22')
        , author: 'Майк'
        , isPersonal: false
  }
    , {
        id: '8'
        , text: 'Если вам нужен Lorem Ipsum для серьёзного проекта, вы наверняка не хотите какой-нибудь шутки, скрытой в середине абзаца.'
        , createdAt: new Date('2021-05-05T12:23:33')
        , author: 'Ник'
        , isPersonal: true
        , to: 'Майк'
  }
    , {
        id: '9'
        , text: 'Также все другие известные генераторы Lorem Ipsum используют один и тот же текст, который они просто повторяют, пока не достигнут нужный объём. Это делает предлагаемый здесь генератор единственным настоящим Lorem Ipsum генератором.'
        , createdAt: new Date('2021-05-05T12:24:01')
        , author: 'Майк'
        , isPersonal: false
  }
    , {
        id: '10'
        , text: 'Он использует словарь из более чем 200 латинских слов, а также набор моделей предложений. В результате сгенерированный Lorem Ipsum выглядит правдоподобно, не имеет повторяющихся абзацей или "невозможных" слов.'
        , createdAt: new Date('2021-05-05T12:25:45')
        , author: 'Ник'
        , isPersonal: true
        , to: 'Майк'
  }
    , {
        id: '11'
        , text: 'Если вам нужен Lorem Ipsum для серьёзного проекта, вы наверняка не хотите какой-нибудь шутки, скрытой в середине абзаца.'
        , createdAt: new Date('2021-05-05T12:27:01')
        , author: 'Майк'
        , isPersonal: false
  }
    , {
        id: '12'
        , text: 'Lorem Ipsum - это текст-"рыба", часто используемый в печати и вэб-дизайне. Lorem Ipsum является стандартной "рыбой" для текстов на латинице с начала XVI века. В то время некий безымянный печатник создал большую коллекцию размеров и форм шрифтов, используя Lorem Ipsum для распечатки образцов.'
        , createdAt: new Date('2021-05-05T12:27:27')
        , author: 'Ник'
        , isPersonal: true
        , to: 'Майк'
  }
    , {
        id: '13'
        , text: 'Lorem Ipsum не только успешно пережил без заметных изменений пять веков, но и перешагнул в электронный дизайн. Его популяризации в новое время послужили публикация листов Letraset с образцами Lorem Ipsum в 60-х годах и, в более недавнее время, программы электронной вёрстки типа Aldus PageMaker, в шаблонах которых используется Lorem Ipsum'
        , createdAt: new Date('2021-05-05T12:28:28')
        , author: 'Майк'
        , isPersonal: false
  }
    , {
        id: '14'
        , text: 'Давно выяснено, что при оценке дизайна и композиции читаемый текст мешает сосредоточиться.'
        , createdAt: new Date('2021-05-05T12:28:55')
        , author: 'Ник'
        , isPersonal: true
        , to: 'Майк'
  }
    , {
        id: '15'
        , text: 'Lorem Ipsum используют потому, что тот обеспечивает более или менее стандартное заполнение шаблона, а также реальное распределение букв и пробелов в абзацах, которое не получается при простой дубликации "Здесь ваш текст.. Здесь ваш текст.. Здесь ваш текст.."'
        , createdAt: new Date('2021-05-05T12:29:29')
        , author: 'Майк'
        , isPersonal: false
  }
    , {
        id: '16'
        , text: 'Многие программы электронной вёрстки и редакторы HTML используют Lorem Ipsum в качестве текста по умолчанию, так что поиск по ключевым словам "lorem ipsum" сразу показывает, как много веб-страниц всё ещё дожидаются своего настоящего рождения. '
        , createdAt: new Date('2021-05-05T12:29:55')
        , author: 'Ник'
        , isPersonal: true
        , to: 'Майк'
  }
    , {
        id: '17'
        , text: 'Многие думают, что Lorem Ipsum - взятый с потолка псевдо-латинский набор слов, но это не совсем так. '
        , createdAt: new Date('2021-05-05T12:30:30')
        , author: 'Майк'
        , isPersonal: false
  }
    , {
        id: '18'
        , text: 'Давно выяснено, что при оценке дизайна и композиции читаемый текст мешает сосредоточиться.'
        , createdAt: new Date('2021-05-05T12:30:40')
        , author: 'Ник'
        , isPersonal: true
        , to: 'Майк'
  }
    , {
        id: '19'
        , text: 'Он использует словарь из более чем 200 латинских слов, а также набор моделей предложений. В результате сгенерированный Lorem Ipsum выглядит правдоподобно, не имеет повторяющихся абзацей или "невозможных" слов.'
        , createdAt: new Date('2021-05-05T12:31:31')
        , author: 'Майк'
        , isPersonal: false
  }
    , {
        id: '20'
        , text: 'Классический текст Lorem Ipsum, используемый с XVI века, приведён ниже. Также даны разделы 1.10.32 и 1.10.33 "de Finibus Bonorum et Malorum" Цицерона и их английский перевод, сделанный H. Rackham, 1914 год.'
        , createdAt: new Date('2021-05-05T12:31:51')
        , author: 'Ник'
        , isPersonal: true
        , to: 'Майк'
  }
    ,{
        id: '26'
        , text: 'В результате он нашёл неоспоримый первоисточник Lorem Ipsum в разделах 1.10.32 и 1.10.33 книги "de Finibus Bonorum et Malorum" ("О пределах добра и зла"), написанной Цицероном в 45 году н.э. Этот трактат по теории этики был очень популярен в эпоху Возрождения. Первая строка Lorem Ipsum, "Lorem ipsum dolor sit amet..", происходит от одной из строк в разделе 1.10.32'
        , createdAt: new Date('2021-05-05T12:32:51')
        , author: 'Рик'
        , isPersonal: false
  },
];
class Message {
    constructor(msg = {}) {
        this.id = msg.id;
        this.createdAt = msg.createdAt;
        this.text = msg.text;
        this.author = msg.author;
        if (!msg.to) {
            this.isPersonal = false;
        }
        else {
            this.isPersonal = true;
            this.to = msg.to;
        }
    }
}
class MessageList {
    static validate(msg) {
        const validateObj = {
            id: (item) => item.id && typeof item.id === "string"
            , text: (item) => item.text && typeof item.text === "string"
            , author: (item) => item.author && typeof item.author === "string"
            , createdAt: (item) => item.createdAt && typeof item.createdAt === "object"
            , isPersonal: (item) => {
                if ((item.isPersonal === false && !item.to) || (item.isPersonal && item.to && typeof item.to === "string")) {
                    return typeof item.isPersonal === "boolean";
                }
            }
        }
        return Object.keys(validateObj).every((key) => validateObj[key](msg));
    }

    constructor(user, messages) {
        this._user = user;
        this._messages = [];

        for (let i = 0; i < messages.length; i++) {

            /*Функция, которая разделяет большие сообщения на несколько маленьких*/
            let isFirst = true; /*для функции splitThisMsg, чтобы не пушить первое сообщение дважды*/
            function splitThisMsg(ourMsg){
                    let cut = ourMsg.text.lastIndexOf(' ', 200);
                    let anotherMsgPart;
                    if (ourMsg.isPersonal) {
                        anotherMsgPart = ({
                            text: ourMsg.text.substr(cut, ourMsg.text.length)
                            , id: `${+new Date() + Math.random() * Math.random()}`
                            , author: ourMsg.author
                            , createdAt: ourMsg.createdAt
                            , isPersonal: ourMsg.isPersonal
                            , to: ourMsg.to
                        });
                    }
                    else {
                        anotherMsgPart = ({
                            text: ourMsg.text.substr(cut, ourMsg.text.length)
                            , id: `${+new Date() + Math.random() * Math.random()}`
                            , author: ourMsg.author
                            , createdAt: ourMsg.createdAt
                            , isPersonal: ourMsg.isPersonal
                        });
                    }

                    if(!isFirst){
                        ourMsg.text = ourMsg.text.substr(0, cut);
                        messages.push(ourMsg);
                    }

                    if (anotherMsgPart.text.length > 200) {
                        isFirst = false;
                        splitThisMsg(anotherMsgPart);
                    }
                    else {
                        return messages.push(anotherMsgPart);
                    }
            }

            if (messages[i].text.length > 200) {
                let cutIndex = messages[i].text.lastIndexOf(' ', 200);
                splitThisMsg(messages[i]);

                messages[i].text = messages[i].text.substr(0, cutIndex);
            }
        }

        messages.forEach(item => {
            this._messages.push(new Message(item));
        });
    }

    get messages() {
        return this._messages;
    }

    get user() {
        return this._user;
    }

    getPage(skip = 0, top = 10, filterConfig = {}) {
        const filterObj = {
            author: (item, author) => !author || item.author.toLowerCase().includes(author.toLowerCase())
            , text: (item, text) => !text || item.text.toLowerCase().includes(text.toLowerCase())
            , dateTo: (item, dateTo) => !dateTo || item.createdAt < dateTo
            , dateFrom: (item, dateFrom) => !dateFrom || item.createdAt > dateFrom
        , };
        let result = [];
        for (let i = 0; i < this._messages.length; i++) {
            if (this._messages[i].author === this.user || this._messages[i].to === this.user || this._messages[i].isPersonal === true || this._messages[i].isPersonal === false) {
                result.push(this._messages[i]);
            }
        }
        Object.keys(filterConfig).forEach(key => {
            result = result.filter(item => filterObj[key](item, filterConfig[key]));
        });
        return result.sort((a, b) => a.createdAt - b.createdAt).slice(skip, top + skip);
    }



//    Разделяем сообщение, если оно больше 200 символов
    static separation(bigMsg) {
            let cutIndex = bigMsg.text.lastIndexOf(' ', 200);
            let anotherMsgPart;
            if (bigMsg.isPersonal) {
                anotherMsgPart = new Message({
                    text: bigMsg.text.substr(cutIndex, bigMsg.text.length)
                    , id: `${+new Date() + Math.random() * Math.random()}`
                    , author: bigMsg.author
                    , createdAt: bigMsg.createdAt
                    , isPersonal: bigMsg.isPersonal
                    , to: bigMsg.to
                });
            }
            else {
                anotherMsgPart = new Message({
                    text: bigMsg.text.substr(cutIndex, bigMsg.text.length)
                    , id: `${+new Date() + Math.random() * Math.random()}`
                    , author: bigMsg.author
                    , createdAt: bigMsg.createdAt
                    , isPersonal: bigMsg.isPersonal
                });
            }
            bigMsg.text = bigMsg.text.substr(0, cutIndex);
            this._messages.push(bigMsg);
            if (anotherMsgPart.text.length > 200) {
                let splitAnotherMsg = MessageList.separation.bind(this);
                splitAnotherMsg(anotherMsgPart);
            }
            else {
                return this._messages.push(anotherMsgPart);
            }
    }


    get(id) {
        return this._messages.find(msg => msg.id === id);
    }

    add(msg) {
        const newMsg = new Message({
            id: `${+new Date()}`
            , createdAt: new Date()
            , text: msg.text
            , author: this.user
            , to: msg.to
        });
        if (this.isPersonal === false) {
            delete this.to;
        }


        if (MessageList.validate(newMsg)) {
//        Если длина больше 200, то сокращаем
            if(newMsg.text.length > 200){
                let splitMsg  = MessageList.separation.bind(this);
                splitMsg(newMsg);
                return true;
            }

            else{
                this._messages.push(newMsg);
                return true;
            }
        }
        else {
            return false;
        }
    }


    remove(id) {
        if (this.get(id) && this.get(id).author === this._user) {
            this._messages = this._messages.filter((item) => item.id !== id);
            return true;
        }
        return false;
    }

    edit(id, msg) {
        if (msg instanceof Object) {
            let oldMsg = this._messages.findIndex(item => item.id === id);
            if (this.user === this._messages[oldMsg].author && (typeof msg.text === 'string' || msg.text === undefined) && (typeof msg.isPersonal === 'boolean' || msg.isPersonal === undefined) && (typeof msg.to === 'string' || msg.to === undefined)) {
                for (let key in msg) {
                    this._messages[oldMsg][key] = msg[key];
                }
                if (msg.isPersonal === false) {
                    delete this._messages[oldMsg].to;
                }
                if (MessageList.validate(this._messages[oldMsg])) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        return false;
    }

    addAll(messages) {
        let incorrectMsg = [];
        for (let i = 0; i < messages.length; i++) {
            if (MessageList.validate(messages[i])) {
                this._messages.push(messages[i]);
            }
            else {
                incorrectMsg.push(messages[i]);
            }
            if (messages[i].isPersonal instanceof Number || messages[i].to instanceof Number) {
                incorrectMsg.push(messages[i]);
            }
        }
        return incorrectMsg;
    }
}
